---
title: '集合框架知识点整理'
date: '2020-08-03'
tags: ['Java SE']
draft: false
summary: '常用知识点总结'
---

##### 集合

```java
/** java集合框架：*   Collection：存放的是单一值*       特点：*           1、可以存放不同类型的数据，而数组只能存放固定类型的数据*           2、当使用arraylist子类实现的时候，初始化的长度是10，当长度不够的时候会自动进行扩容操作*       api方法：*           增加数据的方法*           add：要求必须传入的参数是Object对象，因此当写入基本数据类型的时候，包含了自动拆箱和自动装箱的过程*           addAll:添加另一个集合的元素到此集合中**           删除数据的方法*           clear:只是清空集合中的元素，但是此集合对象并没有被回收*           remove:删除指定元素*           removeAll：删除集合元素**           查询数据的方法*           contains:判断集合中是否包含指定的元素值*           containsAll:判断此集合中是否包含另一个集合*           isEmpty:判断集合是否等于空*           retainAll:若集合中拥有另一个集合的所有元素，返回true，否则返回false*           size:返回当前集合的大小**           //集合转数组的操作*           toArray:将集合转换成数组* */
```

![image-20200514121720326](/static/images/blog/image-20200514121720326.png)

![image-20200514121734482](/static/images/blog/image-20200514121734482.png)

![image-20200514121747635](/static/images/blog/image-20200514121747635.png)

##### List

```java
/** java集合框架：*   List：存放的是单一值*       特点：*           1、可以存放不同类型的数据，而数组只能存放固定类型的数据*           2、当使用arraylist子类实现的时候，初始化的长度是10，当长度不够的时候会自动进行扩容操作*       api方法：*           增加数据的方法*           add：要求必须传入的参数是Object对象，因此当写入基本数据类型的时候，包含了自动拆箱和自动装箱的过程*           addAll:添加另一个集合的元素到此集合中**           删除数据的方法*           clear:只是清空集合中的元素，但是此集合对象并没有被回收*           remove:删除指定元素*           removeAll：删除集合元素**           查询数据的方法*           contains:判断集合中是否包含指定的元素值*           containsAll:判断此集合中是否包含另一个集合*           isEmpty:判断集合是否等于空*           retainAll:若集合中拥有另一个集合的所有元素，返回true，否则返回false*           size:返回当前集合的大小**           //集合转数组的操作*           toArray:将集合转换成数组* */
```

![image-20200514121809284](/static/images/blog/image-20200514121809284.png)

![image-20200514121818097](/static/images/blog/image-20200514121818097.png)

###### 迭代器

```java
/** 在java代码中包含三种循环的方式*   do...while*   while*   for* 还有一种增强for循环的方式，可以简化循环的编写***   所有的集合类都默认实现了Iterable的接口，实现此接口意味着具备了增强for循环的能力，也就是for-each*      增强for循环本质上使用的也是iterator的功能*      方法：*               iterator()*               foreach()*   在iterator的方法中，要求返回一个Iterator的接口子类实例对象*       此接口中包含了*               hasNext()*               next()**   在使用iterator进行迭代的过程中如果删除其中的某个元素会报错，并发操作异常，因此*       如果遍历的同时需要修改元素，建议使用listIterator（），*   ListIterator迭代器提供了向前和向后两种遍历的方式*       始终是通过cursor和lastret的指针来获取元素值及向下的遍历索引*       当使用向前遍历的时候必须要保证指针在迭代器的结果，否则无法获取结果值* */
```

![image-20200514121910889](/static/images/blog/image-20200514121910889.png)

![image-20200514121922127](/static/images/blog/image-20200514121922127.png)

![image-20200514122001163](/static/images/blog/image-20200514122001163.png)

###### LinkedList

![image-20200514122038056](/static/images/blog/image-20200514122038056.png)

![image-20200514122050646](/static/images/blog/image-20200514122050646.png)

###### Vector

```java
/** *      1、Vector也是List接口的一个子类实现 *      2、Vector跟ArrayList一样，底层都是使用数组进行实现的 *      3、面试经常问区别： *          （1）ArrayList是线程不安全的，效率高，Vector是线程安全的效率低 *          （2）ArrayList在进行扩容的时候，是扩容1.5倍，Vector扩容的时候扩容原来的2倍 *
```

##### Set

```java
/**   1、set中存放的是无序，唯一的数据*   2、set不可以通过下标获取对应位置的元素的值，因为无序的特点*   3、使用treeset底层的实现是treemap,利用红黑树来进行实现*   4、设置元素的时候，如果是自定义对象，会查找对象中的equals和hashcode的方法，如果没有，比较的是地址*   5、树中的元素是要默认进行排序操作的，如果是基本数据类型，自动比较，如果是引用类型的话，需要自定义比较器*       比较器分类：*         内部比较器*               定义在元素的类中，通过实现comparable接口来进行实现*         外部比较器*               定义在当前类中，通过实现comparator接口来实现，但是要将该比较器传递到集合中*         注意：外部比较器可以定义成一个工具类，此时所有需要比较的规则如果一致的话，可以复用，而*               内部比较器只有在存储当前对象的时候才可以使用*               如果两者同时存在，使用外部比较器*               当使用比较器的时候，不会调用equals方法* */
```

![image-20200514122123267](/static/images/blog/image-20200514122123267.png)

###### HashSet

![image-20200514122143284](/static/images/blog/image-20200514122143284.png)

![image-20200514122235681](/static/images/blog/image-20200514122235681.png)

![image-20200514122252795](/static/images/blog/image-20200514122252795.png)

![image-20200514122334514](/static/images/blog/image-20200514122334514.png)

###### TreeSet

![image-20200514122417659](/static/images/blog/image-20200514122417659.png)

###### 比较器

```java
/***         内部比较器*               定义在元素的类中，通过实现comparable接口来进行实现*         外部比较器*               定义在当前类中，通过实现comparator接口来实现，但是要将该比较器传递到集合中*         注意：外部比较器可以定义成一个工具类，此时所有需要比较的规则如果一致的话，可以复用，而*               内部比较器只有在存储当前对象的时候才可以使用*               如果两者同时存在，使用外部比较器*               当使用比较器的时候，不会调用equals方法* */
```

![image-20200514122527240](/static/images/blog/image-20200514122527240.png)

![image-20200514122557122](/static/images/blog/image-20200514122557122.png)

###### 二叉树

![image-20200514125045624](/static/images/blog/image-20200514125045624.png)

###### AVL树

![image-20200514125258424](/static/images/blog/image-20200514125258424.png)

###### 红黑树

牺牲完全平衡的特点，部分平衡，换区插入和删除的效率

![image-20200514134304988](/static/images/blog/image-20200514134304988.png)

##### 泛型

```java
/** * 当做一些集合的统一操作的时候，需要保证集合的类型是统一的，此时需要泛型来进行限制 *      优点： *          1、数据安全 *          2、获取数据时效率比较高 *      给集合中的元素设置相同的类型就是泛型的基本需求 *       使用： *          在定义对象的时候，通过<>中设置合理的类型来进行实现 *  泛型的高阶应用： *      1、泛型类 *          在定义类的时候在类名的后面添加,起到占位的作用，类中的方法的返回值类型和属性的类型都可以使用 *      2、泛型接口 *          在定义接口的时候，在接口的名称后添加, *          1、子类在进行实现的时候，可以不填写泛型的类型，此时在创建具体的子类对象的时候才决定使用什么类型 *          2、子类在实现泛型接口的时候，只在实现父类的接口的时候指定父类的泛型类型即可，此时，测试方法中的泛型类型必须要跟子类保持一致 *      3、泛型方法 *          在定义方法的时候，指定方法的返回值和参数是自定义的占位符，可以是类名中的T,也可以是自定义的Q，只不过在使用Q的时候需要使用< *          Q>定义在返回值的前面 *      4、泛型的上限（工作中不用） *          如果父类确定了，所有的子类都可以直接使用 *      5、泛型的下限（工作中不用） *          如果子类确定了，子类的所有父类都可以直接传递参数使用 * * */
```

![image-20200514134340093](/static/images/blog/image-20200514134340093.png)

![image-20200514134358177](/static/images/blog/image-20200514134358177.png)

###### 泛型类

![image-20200514134659227](/static/images/blog/image-20200514134659227.png)

###### 泛型接口

![image-20200514140620622](/static/images/blog/image-20200514140620622.png)

![image-20200514140636471](/static/images/blog/image-20200514140636471.png)

##### Map

###### HashMap

![image-20200514173113121](/static/images/blog/image-20200514173113121.png) ![image-20200514173130393](/static/images/blog/image-20200514173130393.png) ![image-20200514173144162](/static/images/blog/image-20200514173144162.png)
