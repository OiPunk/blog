---
title: 'IOC基本使用'
date: '2020-05-22'
tags: ['框架', 'Spring', 'IOC']
draft: false
summary: '如何在xml中配置bean对象及IOC源码分析'
---

# Spring IOC基本使用

### 1、spring_helloworld

##### **(1)使用手动加载jar包的方式实现，分为三个步骤，现在几乎不用**

- **导包：导入这五个包即可**

  commons-logging-1.2.jar  
  spring-beans-5.2.3.RELEASE.jar  
  spring-context-5.2.3.RELEASE.jar  
  spring-core-5.2.3.RELEASE.jar  
  spring-expression-5.2.3.RELEASE.jar

- **写配置**

  Person.java

  ```java
  package com.oi.bean;public class Person {    private int id;    private String name;    private int age;    private String gender;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    @Override    public String toString() {        return "Person{" +                "id=" + id +                ", name='" + name + '\'' +                ", age=" + age +                ", gender='" + gender + '\'' +                '}';    }}
  ```

  ioc.xml

- **测试**

SpringDemoTest.java

```java
package com.oi.test;import com.oi.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringDemoTest {    public static void main(String[] args) {        //ApplicationContext:表示ioc容器        //ClassPathXmlApplicationContext:表示从当前classpath路径中获取xml文件的配置        //根据spring的配置文件来获取ioc容器对象        ApplicationContext context = new ClassPathXmlApplicationContext("ioc.xml");        Person person = (Person) context.getBean("person");        System.out.println(person);    }}
```

##### **(2)使用maven的方式来构建项目**

- **创建maven项目**

  定义项目的groupId、artifactId

- **添加对应的pom依赖**

  pom.xml

  ```xml
      4.0.0    com.oi    spring_demo    1.0-SNAPSHOT                                org.springframework            spring-context            5.2.3.RELEASE
  ```

- **编写代码**

  Person.java

  ```java
  package com.oi.bean;public class Person {    private int id;    private String name;    private int age;    private String gender;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    @Override    public String toString() {        return "Person{" +                "id=" + id +                ", name='" + name + '\'' +                ", age=" + age +                ", gender='" + gender + '\'' +                '}';    }}
  ```

- **测试**

  MyTest.java

```java
import com.oi.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext("ioc.xml");        Person person = (Person) context.getBean("person");        System.out.println(person);    }}
```

**总结：**

​ 以上两种方式创建spring的项目都是可以的，但是在现在的企业开发环境中使用更多的还是maven这样的方式，无须自己处理jar之间的依赖关系，也无须提前下载jar包，只需要配置相关的pom即可，因此推荐大家使用maven的方式，具体的maven操作大家可以看maven的详细操作文档。

​ **搭建spring项目需要注意的点：**

​ 1、一定要将配置文件添加到类路径中，使用idea创建项目的时候要放在resource目录下

​ 2、导包的时候别忘了commons-logging-1.2.jar包

​ **细节点：**

​ 1、ApplicationContext就是IOC容器的接口，可以通过此对象获取容器中创建的对象

​ 2、对象在Spring容器创建完成的时候就已经创建完成，不是需要用的时候才创建

​ 3、对象在IOC容器中存储的时候都是单例的，如果需要多例需要修改属性

​ 4、创建对象给属性赋值的时候是通过setter方法实现的

​ 5、对象的属性是由setter/getter方法决定的，而不是定义的成员属性

### 2、spring对象的获取及属性赋值方式

##### **1、通过bean的id获取IOC容器中的对象（上面已经用过）**

##### **2、通过bean的类型获取对象**

​ MyTest.java

```java
import com.oi.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext("ioc.xml");        Person bean = context.getBean(Person.class);        System.out.println(bean);    }}
```

注意：通过bean的类型在查找对象的时候，在配置文件中不能存在两个类型一致的bean对象，如果有的话，可以通过如下方法

MyTest.java

```java
import com.oi.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext("ioc.xml");        Person person = context.getBean("person", Person.class);        System.out.println(person);    }}
```

##### **3、通过构造器给bean对象赋值**

ioc.xml

```xml
                                                                                                将person的age类型设置为Integer类型public Person(int id, String name, Integer age) {       this.id = id;       this.name = name;       this.age = age;       System.out.println("Age");   }   public Person(int id, String name, String gender) {       this.id = id;       this.name = name;       this.gender = gender;       System.out.println("gender");   }
```

##### **4、通过命名空间为bean赋值，简化配置文件中属性声明的写法**

​ 1、导入命名空间

​ 2、添加配置

##### **5、为复杂类型进行赋值操作**

​ 在之前的测试代码中，我们都是给最基本的属性进行赋值操作，在正常的企业级开发中还会遇到给各种复杂类型赋值，如集合、数组、其他对象等。

​ Person.java

```java
package com.oi.bean;import java.util.*;public class Person {    private int id;    private String name="dahuang";    private int age;    private String gender;    private Address address;    private String[] hobbies;    private List books;    private Set sets;    private Map maps;    private Properties properties;    public Person(int id, String name, int age, String gender) {        this.id = id;        this.name = name;        this.age = age;        this.gender = gender;        System.out.println("有参构造器");    }    public Person(int id, String name, int age) {        this.id = id;        this.name = name;        this.age = age;        System.out.println("Age");    }    public Person(int id, String name, String gender) {        this.id = id;        this.name = name;        this.gender = gender;        System.out.println("gender");    }    public Person() {    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public Address getAddress() {        return address;    }    public void setAddress(Address address) {        this.address = address;    }    public List getBooks() {        return books;    }    public void setBooks(List books) {        this.books = books;    }    public Map getMaps() {        return maps;    }    public void setMaps(Map maps) {        this.maps = maps;    }    public Properties getProperties() {        return properties;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public String[] getHobbies() {        return hobbies;    }    public void setHobbies(String[] hobbies) {        this.hobbies = hobbies;    }    public Set getSets() {        return sets;    }    public void setSets(Set sets) {        this.sets = sets;    }    @Override    public String toString() {        return "Person{" +                "id=" + id +                ", name='" + name + '\'' +                ", age=" + age +                ", gender='" + gender + '\'' +                ", address=" + address +                ", hobbies=" + Arrays.toString(hobbies) +                ", books=" + books +                ", sets=" + sets +                ", maps=" + maps +                ", properties=" + properties +                '}';    }}
```

Book.java

```java
package com.oi.bean;public class Book {    private String name;    private String author;    private double price;    public Book() {    }    public Book(String name, String author, double price) {        this.name = name;        this.author = author;        this.price = price;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getAuthor() {        return author;    }    public void setAuthor(String author) {        this.author = author;    }    public double getPrice() {        return price;    }    public void setPrice(double price) {        this.price = price;    }    @Override    public String toString() {        return "Book{" +                "name='" + name + '\'' +                ", author='" + author + '\'' +                ", price=" + price +                '}';    }}
```

Address.java

```java
package com.oi.bean;public class Address {    private String province;    private String city;    private String town;    public Address() {    }    public Address(String province, String city, String town) {        this.province = province;        this.city = city;        this.town = town;    }    public String getProvince() {        return province;    }    public void setProvince(String province) {        this.province = province;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public String getTown() {        return town;    }    public void setTown(String town) {        this.town = town;    }    @Override    public String toString() {        return "Address{" +                "province='" + province + '\'' +                ", city='" + city + '\'' +                ", town='" + town + '\'' +                '}';    }}
```

ioc.xml

```xml
                                                                                                                                                                                                                                                                                                                                       aaa                222                                                                book                movie                game                                                                111                222                222
```

##### 6、继承关系bean的配置

ioc.xml

如果想实现Java文件的抽象类，不需要将当前bean实例化的话，可以使用abstract属性

##### 7、bean对象创建的依赖关系

​ bean对象在创建的时候是按照bean在配置文件的顺序决定的，也可以使用depend-on标签来决定顺序

ioc.xml

##### 8、bean的作用域控制，是否是单例

ioc.xml

##### 9、利用工厂模式创建bean对象

​ 在之前的案例中，所有bean对象的创建都是通过反射得到对应的bean实例，其实在spring中还包含另外一种创建bean实例的方式，就是通过工厂模式进行对象的创建

​ 在利用工厂模式创建bean实例的时候有两种方式，分别是静态工厂和实例工厂。

​ 静态工厂：工厂本身不需要创建对象，但是可以通过静态方法调用，对象=工厂类.静态工厂方法名（）；

​ 实例工厂：工厂本身需要创建对象，工厂类 工厂对象=new 工厂类；工厂对象.get对象名（）；

PersonStaticFactory.java

```java
package com.oi.factory;import com.oi.bean.Person;public class PersonStaticFactory {    public static Person getPerson(String name){        Person person = new Person();        person.setId(1);        person.setName(name);        return person;    }}
```

ioc.xml

PersonInstanceFactory.java

```java
package com.oi.factory;import com.oi.bean.Person;public class PersonInstanceFactory {    public Person getPerson(String name){        Person person = new Person();        person.setId(1);        person.setName(name);        return person;    }}
```

ioc.xml

##### 10、继承FactoryBean来创建对象

​ FactoryBean是Spring规定的一个接口，当前接口的实现类，Spring都会将其作为一个工厂，但是在ioc容器启动的时候不会创建实例，只有在使用的时候才会创建对象

MyFactoryBean.java

```java
package com.oi.factory;import com.oi.bean.Person;import org.springframework.beans.factory.FactoryBean;/** * 实现了FactoryBean接口的类是Spring中可以识别的工厂类，spring会自动调用工厂方法创建实例 */public class MyFactoryBean implements FactoryBean {    /**     * 工厂方法，返回需要创建的对象     * @return     * @throws Exception     */    @Override    public Person getObject() throws Exception {        Person person = new Person();        person.setName("maliu");        return person;    }    /**     * 返回创建对象的类型,spring会自动调用该方法返回对象的类型     * @return     */    @Override    public Class getObjectType() {        return Person.class;    }    /**     * 创建的对象是否是单例对象     * @return     */    @Override    public boolean isSingleton() {        return false;    }}
```

ioc.xml

##### 11、bean对象的初始化和销毁方法

​ 在创建对象的时候，我们可以根据需要调用初始化和销毁的方法

Address.java

```java
package com.oi.bean;public class Address {    private String province;    private String city;    private String town;    public Address() {        System.out.println("address被创建了");    }    public Address(String province, String city, String town) {        this.province = province;        this.city = city;        this.town = town;    }    public String getProvince() {        return province;    }    public void setProvince(String province) {        this.province = province;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public String getTown() {        return town;    }    public void setTown(String town) {        this.town = town;    }    public void init(){        System.out.println("对象被初始化");    }        public void destory(){        System.out.println("对象被销毁");    }        @Override    public String toString() {        return "Address{" +                "province='" + province + '\'' +                ", city='" + city + '\'' +                ", town='" + town + '\'' +                '}';    }}
```

ioc.xml

MyTest.java

```java
import com.oi.bean.Address;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext("ioc2.xml");        Address address = context.getBean("address", Address.class);        System.out.println(address);        //applicationContext没有close方法，需要使用具体的子类        ((ClassPathXmlApplicationContext)context).close();    }}
```

##### 12、配置bean对象初始化方法的前后处理方法

​ spring中包含一个BeanPostProcessor的接口，可以在bean的初始化方法的前后调用该方法，如果配置了初始化方法的前置和后置处理器，无论是否包含初始化方法，都会进行调用

MyBeanPostProcessor.java

```java
package com.oi.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor {    /**     * 在初始化方法调用之前执行     * @param bean  初始化的bean对象     * @param beanName  xml配置文件中的bean的id属性     * @return     * @throws BeansException     */    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println("postProcessBeforeInitialization:"+beanName+"调用初始化前置方法");        return bean;    }    /**     * 在初始化方法调用之后执行     * @param bean     * @param beanName     * @return     * @throws BeansException     */    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println("postProcessAfterInitialization:"+beanName+"调用初始化后缀方法");        return bean;    }}
```

ioc.xml

### 3、spring创建第三方bean对象

​ 在Spring中，很多对象都是单实例的，在日常的开发中，我们经常需要使用某些外部的单实例对象，例如数据库连接池，下面我们来讲解下如何在spring中创建第三方bean实例。

​ 1、导入数据库连接池的pom文件

```xml
    com.alibaba    druid    1.1.21    mysql    mysql-connector-java    5.1.47
```

​ 2、编写配置文件

ioc.xml

​ 3、编写测试文件

MyTest.java

```java
import com.alibaba.druid.pool.DruidDataSource;import com.oi.bean.Address;import com.oi.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.sql.SQLException;public class MyTest {    public static void main(String[] args) throws SQLException {        ApplicationContext context = new ClassPathXmlApplicationContext("ioc3.xml");        DruidDataSource dataSource = context.getBean("dataSource", DruidDataSource.class);        System.out.println(dataSource);        System.out.println(dataSource.getConnection());    }}
```

### 4、spring引用外部配置文件

在resource中添加dbconfig.properties

```properties
username=rootpassword=123456url=jdbc:mysql://localhost:3306/demodriverClassName=com.mysql.jdbc.Driver
```

编写配置文件

### 5、spring基于xml文件的自动装配

​ 当一个对象中需要引用另外一个对象的时候，在之前的配置中我们都是通过property标签来进行手动配置的，其实在spring中还提供了一个非常强大的功能就是自动装配，可以按照我们指定的规则进行配置，配置的方式有以下几种：

​ default/no：不自动装配

​ byName：按照名字进行装配，以属性名作为id去容器中查找组件，进行赋值，如果找不到则装配null

​ byType：按照类型进行装配,以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的bean对象，那么会报异常，如果找不到则装配null

​ constructor：按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接装配null；如果按照类型找到了多个，那么就使用参数名作为id继续匹配，找到就装配，找不到就装配null

ioc.xml

### 6、SpEL的使用

​ SpEL:Spring Expression Language,spring的表达式语言，支持运行时查询操作对象

​ 使用#{…}作为语法规则，所有的大括号中的字符都认为是SpEL.

ioc.xml
